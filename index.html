<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Aadi — Terminal Portfolio</title>
  <meta name="description" content="A minimal, SerenityOS-flavored terminal portfolio for GitHub Pages. Markdown blog + vi pager." />
  <style>
    /* SerenityOS-inspired: light, crisp, 90s desktop vibes (blue titlebar, gray chrome) */
    :root{
      --bg:#cfd6dc;           /* light gray desktop */
      --panel:#d4d0c8;        /* window surface */
      --panel-border:#9aa4ad; /* classic bevel */
      --titlebar-start:#ebbe94; /* warm tan gradient */
      --titlebar-end:#a97b3c;
      --titlebar-text:#ffffff;
      --text:#1e2327;         /* dark text */
      --muted:#5a6772;
      --dir:#0a5c3a;          /* directory green */
      --file:#093a79;         /* file blue */
      --danger:#b00020;       /* error red */
      --link:#004bd6;         /* link blue */
      --ansi-green:#0a5c3a;
      --ansi-blue:#9b7b4a;    /*FIX ME: I need to change the var name to match the current colour*/
      --ansi-yellow:#a06a00;
      --ansi-magenta:#7b2fb0;
      --shadow: 0 10px 30px rgba(31, 49, 86, .25);
    }
    html,body{height:100%}
    body{margin:0; background:var(--bg); color:var(--text);
      font:15px/1.6 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }
    .wrap{max-width:980px; margin:40px auto; padding:0 16px}
    .window{background:var(--panel); border-radius:8px; box-shadow:var(--shadow); overflow:hidden; border:1px solid var(--panel-border)}
    .titlebar{display:flex; align-items:center; padding:8px 10px; background:linear-gradient(180deg,var(--titlebar-start),var(--titlebar-end)); color:var(--titlebar-text); user-select:none}
    .titlebar .dots{display:flex; gap:6px; margin-right:10px}
    .dot{width:10px;height:10px;border:1px solid rgba(0,0,0,.25); box-shadow:inset 0 1px 0 rgba(255,255,255,.4); border-radius:2px}
    .dot.red{background:#e66}
    .dot.yellow{background:#f3d165}
    .dot.green{background:#9bd18b}
    .title{font-weight:600; font-size:12px; opacity:.95}
    .screen{padding:18px; min-height:65vh; max-height:70vh; overflow:auto}
    .line{display:block; white-space:pre-wrap; word-break:break-word}
    .prompt{color:var(--ansi-green)}
    .path{color:var(--ansi-blue)}
    .caret{display:inline-block; width:9px; height:1.2em; translate:0 .18em; background:var(--text); animation:blink 1s steps(1,end) infinite}
    #input[contenteditable]{caret-color:transparent;} #input[contenteditable]:focus{outline:none;}
    #vi-cmd[contenteditable]{caret-color:transparent;} #vi-cmd[contenteditable]:focus{outline:none;}
    @keyframes blink{50%{opacity:0}}
    .dir{color:var(--dir); font-weight:700}
    .file{color:var(--file)}
    .error{color:var(--danger)}
    a{color:var(--link); text-decoration:none}
    a:hover{text-decoration:underline}
    .hint{color:var(--muted); font-size:12px; margin-top:12px}
    .kbd{background:#f1f3f5; border:1px solid #b8c1c9; padding:1px 5px; border-radius:4px; font-size:12px}
    /* vi pager visuals */
    .vi-header{background:#dde3ea; border:1px solid var(--panel-border); padding:6px 8px; border-radius:6px; margin-bottom:8px}
    .vi-footer{background:#dde3ea; border:1px solid var(--panel-border); padding:6px 8px; border-radius:6px; margin-top:8px; font-size:13px; color:var(--muted)}
    .hl{background:#fff2a8}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="window" role="region" aria-label="Terminal Portfolio">
      <div class="titlebar">
        <div class="dots"><span class="dot red"></span><span class="dot yellow"></span><span class="dot green"></span></div>
        <span class="title">Terminal — Linux style</span>
      </div>
      <div class="screen" id="screen" aria-live="polite" aria-atomic="false"></div>
    </div>
    <div class="hint">Type <span class="kbd">help</span>. ↑/↓ for history, <span class="kbd">Tab</span> to autocomplete. In <span class="kbd">vi</span>: <span class="kbd">j</span>/<span class="kbd">k</span> scroll, <span class="kbd">g g</span> top, <span class="kbd">G</span> bottom, <span class="kbd">/</span> search, <span class="kbd">n</span>/<span class="kbd">N</span> next/prev, <span class="kbd">:q</span> quit.</div>
  </div>

  <script>
  // --- Faux filesystem + router (Markdown-aware) ---------------------------
  const FS = {
    name: '/', type: 'dir', children: [
      { name: 'Home', type: 'dir', children: [
        { name: 'welcome.txt', type: 'file', href: 'posts/welcome.txt' }
      ]},
      { name: 'About', type: 'dir', children: [
        { name: 'about.txt', type: 'file', content: `I'm a software developer focused on low-level systems, DB engine internals, and XR.\n- IBM Db2 intern (C++)\n- UCalgary Mixed Reality — VP, software\n- Interests: OS, embedded, HPC\nLinks: https://github.com/aadic0  https://www.linkedin.com/in/aadichauhan/` },
        { name: 'skills.txt', type: 'file', content: `C, C++, Python, JS; PIC24F; Unity (Quest 3); Docker, Jenkins; SQL.` }
      ]},
      { name: 'Projects', type: 'dir', children: [
        { name: 'Custom_kernel', type: 'file', content: `Custom kernel playground\nWhat: Hobby kernel experiments (paging, syscalls, scheduler).\nRepo: https://github.com/REPO_PLACEHOLDER` },
        { name: 'AR_headset', type: 'file', content: `AR Headset\nLattePanda + Leap Motion; world-locked windows.\nRepo: https://github.com/REPO_PLACEHOLDER` }
      ]},
      { name: 'Blog', type: 'dir', children: [
        { name: 'hello-terminal.md', type: 'file', href: 'posts/hello-terminal.md' },
        { name: 'perf-notes.md', type: 'file', href: 'posts/perf-notes.md' }
      ]},
      { name: 'Resume.pdf', type: 'file', href: 'resume.pdf', content: 'Open resume link: ./resume.pdf' },
      { name: 'Contact', type: 'dir', children: [
        { name: 'email.txt', type: 'file', content: `Email: aadityasinh.chauhan@ucalgary.ca` },
        { name: 'Github.txt', type: 'file', content: `GitHub: https://github.com/aadic0` },
        { name: 'Linkedin.txt', type: 'file', content: `LinkedIn: https://www.linkedin.com/in/aadi-chauhan/` }
      ]}
    ]
  };

  const screen = document.getElementById('screen');
  window.addEventListener('focus',()=>{if(state.mode==='shell')focusLatestInput();});document.addEventListener('visibilitychange',()=>{if(!document.hidden&&state.mode==='shell')focusLatestInput();});screen.addEventListener('mousedown',()=>{if(state.mode==='shell')focusLatestInput();});
  document.addEventListener('visibilitychange', ()=> { if(!document.hidden && state.mode==='shell') focusLatestInput(); });
  screen.addEventListener('mousedown', (e)=> { if(state.mode==='shell') focusLatestInput(); });

  const state = {
    cwd: [FS], history: [], histIdx: -1,
    mode: 'shell', vi: { buffer:null, isMarkdown:false, search:'', marks:{} }
  };
  const username='guest', hostname='aadi';

  // Utilities; i dont care that making all my helper functions one line is a bad development choice, this shit looks cool as hell
  function prompt(){ return `<span class="prompt">${username}@${hostname}</span>:<span class="path">${getCwdPath()}</span>$`; }
  function getCwdPath(){ const names = state.cwd.map(n=>n.name).filter((_,i)=>i>0); return `~/${names.join('/')}`.replace(/\/+$/, ''); }
  function findChild(dir,name){ return (dir.children||[]).find(c=>c.name.toLowerCase()===name.toLowerCase()); }
  function list(dir){ return (dir.children||[]).map(c=> c.type==='dir'?`<span class="dir">${c.name}</span>`:`<span class="file">${c.name}</span>`).join('  '); }
  function printLine(html){ const el=document.createElement('div'); el.className='line'; el.innerHTML=html; screen.appendChild(el); screen.scrollTop=screen.scrollHeight; }
  function printBlock(text){ text.split('\n').forEach(l=>printLine(l)); }
  function newInputLine(){ finalizeCurrentInput(); const row=document.createElement('div'); row.className='line'; row.innerHTML=`${prompt()} <span id="input" contenteditable spellcheck="false" aria-label="terminal input"></span><span class="caret" aria-hidden="true"></span>`; screen.appendChild(row); placeCaretAtEnd(document.getElementById('input')); screen.scrollTop=screen.scrollHeight; }
  function finalizeCurrentInput(){ const prev = document.getElementById('input'); if(prev){ prev.removeAttribute('id'); prev.setAttribute('contenteditable','false'); const caret = prev.nextElementSibling; if(caret && caret.classList.contains('caret')) caret.remove();}}
  function placeCaretAtEnd(el){ el?.focus(); const r=document.createRange(); r.selectNodeContents(el); r.collapse(false); const s=window.getSelection(); s.removeAllRanges(); s.addRange(r); }
  function resolvePathTokensFrom(startStack,tokens){ let stack=[...startStack]; for(const tok of tokens){ if(tok==='.'||tok==='') continue; if(tok==='..'){ if(stack.length>1) stack.pop(); continue; } const cur=stack[stack.length-1]; const child=findChild(cur,tok); if(!child) return {ok:false,stack,missing:tok}; stack.push(child);} return {ok:true,stack}; }
  function extractFirstUrl(text){ const re = /https?:\/\/[^\s)"'>]+/; const m = re.exec(text||''); return m?m[0]:null; }
  function renderViCmdLine(){ const row = document.createElement('div'); row.className = 'line'; row.innerHTML = `:<span id="vi-cmd" contenteditable spellcheck="false" aria-label="vi command"></span><span class="caret" aria-hidden="true"></span>`; screen.appendChild(row); placeCaretAtEnd(document.getElementById('vi-cmd')); screen.scrollTop = screen.scrollHeight; }
  function isBinaryByExt(name){ return /\.(pdf|png|jpe?g|gif|webp|zip)$/i.test(name); } // I added a bunch more extensions for the future, most of these are unused :P
  function isPrintableKey(e){ return e.key && e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey; }
  function focusLatestInput(insertChar){const el=document.getElementById('input');if(!el)return false;if(document.activeElement!==el)placeCaretAtEnd(el);if(insertChar){el.textContent+=insertChar;placeCaretAtEnd(el);}return true;}


  // Shell
  function handleShell(cmd){
    const [base, ...restRaw] = cmd.trim().split(/\s+/); const rest = restRaw.join(' ');
    if(!base){ newInputLine(); return; }
    switch(base){
      case 'help':
        case 'help':printBlock(`Available commands:\n  ls                List items\n  cd &lt;dir&gt;          Change directory (.. & absolute names supported)\n  vi &lt;file&gt;         View file content (Markdown supported)\n  clear             Clear the screen\n  open &lt;file|url&gt;   Open first URL in the file or a given URL\n  pwd               Print working directory\n  test              Run built-in checks`);break;
        break;
      case 'ls': printLine(list(state.cwd.at(-1))); break;
      case 'pwd': printLine(getCwdPath()); break;
      case 'clear': screen.innerHTML=''; break;
      case 'cd': {
        if(!rest){ state.cwd=[FS]; break; }
        const parts=rest.split('/').filter(Boolean);
        const start=(state.cwd.length===1||/^[A-Za-z]/.test(parts[0]))?[FS]:[...state.cwd];
        const resolved=resolvePathTokensFrom(start,parts);
        if(!resolved.ok||resolved.stack.at(-1).type!=='dir'){ printLine(`<span class="error">cd: no such directory: ${rest}</span>`);} else { state.cwd=resolved.stack; location.hash="#"+encodeURIComponent(state.cwd.map(n=>n.name).slice(1).join('/')); }
        break; }
      case 'vi': return openVi(rest);

      case 'open': {
        if(!rest){ printLine(`<span class="error">open: path or url required</span>`); break; }

        // Absolute only for ~/ or / ; otherwise relative to CWD
        let startStack = [...state.cwd];
        let pathArg = rest.trim();
        if (pathArg.startsWith('~/') || pathArg.startsWith('/')) {
            startStack = [FS];
            pathArg = pathArg.replace(/^~?\//,'');
        }

        // If it looks like a URL, open directly
        if (/^https?:\/\//i.test(pathArg)) { window.open(pathArg,'_blank','noopener'); break; }

        const parts = pathArg.split('/').filter(Boolean);
        const resolved = resolvePathTokensFrom(startStack, parts);
        const node = resolved.ok ? resolved.stack.at(-1) : null;

        if(node?.type==='file'){
            const url = node.href || extractFirstUrl(node.content);
            if(url){ window.open(url,'_blank','noopener'); printLine(`Opened: ${url}`); }
            else { printLine(`<span class="error">open: no URL in file</span>`); }
        } else {
            printLine(`<span class="error">open: not a file or URL</span>`);
        }
        break; }

      case 'test': runTests(); break;
      default: printLine(`<span class="error">Command not found:</span> ${base}. Type <span class="file">help</span>.`);
    }
    newInputLine();
  }

  // vi pager (Markdown-aware)
  // async function openVi(arg){
  //   if(!arg){ printLine(`<span class="error">vi: file name required</span>`); newInputLine(); return; }

  //   // Resolve path: default relative; absolute only for ~/ or /
  //   let startStack = [...state.cwd];
  //   let pathArg = arg.trim();
  //   if (pathArg.startsWith('~/') || pathArg.startsWith('/')) {
  //       startStack = [FS];
  //       pathArg = pathArg.replace(/^~?\//,'');
  //   }

  //   const parts = pathArg.split('/').filter(Boolean);
  //   const resolved = resolvePathTokensFrom(startStack, parts);
  //   const node = resolved.ok ? resolved.stack.at(-1) : null;

  //   if(!node){ printLine(`<span class="error">vi: ${arg}: No such file</span>`); newInputLine(); return; }
  //   if(node.type==='dir'){ printLine(`<span class="error">vi: ${arg}: Is a directory</span>`); newInputLine(); return; }

  //   let content=''; let isMarkdown=false;
  //   if(node.href && !isBinaryByExt(node.name)){
  //     try {
  //       const res = await fetch(node.href);
  //       content = await res.text();
  //       isMarkdown = /\.md$/i.test(node.name) || /markdown|md/.test(res.headers.get('content-type')||'');
  //     } catch {
  //       content = `Failed to load ${node.href}`;
  //     }
  //   } else {
  //     // For binaries (e.g., .pdf) or files without href, just display a link or inline text
  //     content = node.content || (node.href ? `Open link: ${node.href}` : '');
  //     isMarkdown = /\.md$/i.test(node.name);
  //   }

  //   state.mode='vi'; state.vi.buffer = { name: node.name, raw: content, isMarkdown };
  //   renderVi();
  // }
  async function openVi(arg){
    if(!arg){ printLine(`<span class="error">vi: file name required</span>`); newInputLine(); return; }

    // Resolve path: relative by default; absolute only for ~/ or /
    let startStack = [...state.cwd];
    let pathArg = arg.trim();
    if (pathArg.startsWith('~/') || pathArg.startsWith('/')) {
      startStack = [FS];
      pathArg = pathArg.replace(/^~?\//,'');
    }

    const parts = pathArg.split('/').filter(Boolean);
    const resolved = resolvePathTokensFrom(startStack, parts);
    const node = resolved.ok ? resolved.stack.at(-1) : null;

    if(!node){ printLine(`<span class="error">vi: ${arg}: No such file</span>`); newInputLine(); return; }
    if(node.type==='dir'){ printLine(`<span class="error">vi: ${arg}: Is a directory</span>`); newInputLine(); return; }

    // Compute an absolute, ~-less path for the viewer page
    const abs = resolved.stack.map(n => n.name).slice(1).join('/'); // e.g., "Home/welcome.txt"
    location.href = `vi.html?p=${encodeURIComponent(abs)}`;
  }

  function mdToHtml(md){
    // very tiny markdown renderer (headings, code, bold/italic, links, lists)
    let html = md
      .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    // code fences
    html = html.replace(/```([\s\S]*?)```/g, (m,code)=>`<pre><code>${code}</code></pre>`);
    // headings
    html = html.replace(/^######\s?(.*)$/gm,'<h6>$1</h6>')
               .replace(/^#####\s?(.*)$/gm,'<h5>$1</h5>')
               .replace(/^####\s?(.*)$/gm,'<h4>$1</h4>')
               .replace(/^###\s?(.*)$/gm,'<h3>$1</h3>')
               .replace(/^##\s?(.*)$/gm,'<h2>$1</h2>')
               .replace(/^#\s?(.*)$/gm,'<h1>$1</h1>');
    // bold/italic
    html = html.replace(/\*\*(.*?)\*\*/g,'<strong>$1</strong>')
               .replace(/\*(.*?)\*/g,'<em>$1</em>')
               .replace(/`([^`]+)`/g,'<code>$1</code>');
    // links
    html = html.replace(/\[(.*?)\]\((https?:\/\/[^\s)]+)\)/g,'<a href="$2" target="_blank" rel="noopener">$1<\/a>');
    // lists
    html = html.replace(/^\s*\*\s+(.*)$/gm,'<li>$1</li>');
    html = html.replace(/(<li>[^<]*<\/li>\n?)+/g, m=>`<ul>${m}</ul>`);
    // paragraphs
    html = html.replace(/^(?!<h\d|<ul>|<pre>|<li>|<\/li>|<\/ul>|<p>|<\/p>)(.+)$/gm,'<p>$1</p>');
    return html;
  }

  function renderVi(){
    const { name, raw, isMarkdown } = state.vi.buffer;
    printLine(`<div class='vi-header'>~ ${name} <span style='color:var(--ansi-yellow)'>readonly</span></div>`);
    const container = document.createElement('div'); container.className='line';
    container.innerHTML = isMarkdown ? mdToHtml(raw) : raw.replace(/\n/g,'<br>');
    container.id = 'vi-content'; screen.appendChild(container);
    printLine(`<div class='vi-footer'>:q to quit — <span class='kbd'>j/k</span> scroll, <span class='kbd'>PgUp/PgDn</span>, <span class='kbd'>g g</span>/<span class='kbd'>G</span>, <span class='kbd'>/</span>search</div>`);
    screen.scrollTop = 0;
  }

  function quitVi(){ state.mode='shell'; state.vi.buffer=null; printLine(""); newInputLine(); }

  // Input & keybinds
  document.addEventListener('keydown',(e)=>{
    const input=document.getElementById('input');
    if(state.mode==='vi'){
      // navigation keys
      if(['j','k','g','G','/','n','N'].includes(e.key) || e.key==='PageDown' || e.key==='PageUp'){
        e.preventDefault();
        const step = 24; // px per j/k
        switch(e.key){
          case 'j': screen.scrollTop = Math.min(screen.scrollTop + step, screen.scrollHeight); break;
          case 'k': screen.scrollTop = Math.max(screen.scrollTop - step, 0); break;
          case 'PageDown': screen.scrollTop = Math.min(screen.scrollTop + screen.clientHeight*0.9, screen.scrollHeight); break;
          case 'PageUp': screen.scrollTop = Math.max(screen.scrollTop - screen.clientHeight*0.9, 0); break;
          case 'g':
            if(state._gSeen){ screen.scrollTop = 0; state._gSeen=false; }
            else { state._gSeen=true; setTimeout(()=>state._gSeen=false,400); }
            break;
          case 'G': screen.scrollTop = screen.scrollHeight; break;
          case '/':
            const q = prompt('Search');
            if(q){ state.vi.search=q; highlightSearch(q); findNext(true); }
            break;
          case 'n': findNext(true); break;
          case 'N': findNext(false); break;
        }
        return;
      }
      if(e.key===':'){ e.preventDefault(); state.mode='vi-cmd'; renderViCmdLine(); return; }
      return; // ignore other keys in vi
    }

    // vi command mode
    if(state.mode==='vi-cmd'){
    if(e.key==='Enter'){
        e.preventDefault();
        const cmdEl = document.getElementById('vi-cmd');
        const raw = (cmdEl?.textContent || '').trim();

        if(cmdEl){
        cmdEl.removeAttribute('id');
        cmdEl.setAttribute('contenteditable','false');
        const caret = cmdEl.nextElementSibling;
        if(caret && caret.classList.contains('caret')) caret.remove();
        }

        if(raw === 'q' || raw === 'q!'){
        quitVi(); // exits vi and prints a shell prompt
        } else {
        printLine(`<span class='error'>:${raw} not recognized (use :q)</span>`);
        state.mode = 'vi'; // stay in vi, do NOT create a shell prompt
        }
    }
    return;
    }

    // If we lost focus (active element isn't the input), refocus and don't lose the first char
    if(state.mode==='shell' && input && document.activeElement !== input){
      if(isPrintableKey(e)){
        e.preventDefault();           // stop the event from going nowhere
        focusLatestInput(e.key);      // refocus and insert the char
        return;                       // we're done handling this keystroke
      } else {
        // for arrows/tab/backspace/etc.: just refocus so the next key works
        focusLatestInput();
        // don't return; let normal handling continue
      }
    }

    // normal shell input
    if(!input) return;
    if(e.key==='ArrowUp'){ e.preventDefault(); if(state.history.length){ state.histIdx=Math.max(0,state.histIdx-1); input.textContent=state.history[state.histIdx]; placeCaretAtEnd(input);} return; }
    if(e.key==='ArrowDown'){ e.preventDefault(); if(state.history.length){ state.histIdx=Math.min(state.history.length,state.histIdx+1); input.textContent= state.histIdx===state.history.length?'':state.history[state.histIdx]; placeCaretAtEnd(input);} return; }
    if(e.key==='Tab'){
      e.preventDefault();
      const parts=input.textContent.split(/\s+/);
      const cur=state.cwd.at(-1);
      if(parts.length>=2){
        const fragment=parts.at(-1).toLowerCase();
        const matches=(cur.children||[]).filter(c=>c.name.toLowerCase().startsWith(fragment));
        if(matches.length===1){ parts[parts.length-1]=matches[0].name; input.textContent=parts.join(' '); placeCaretAtEnd(input); }
        else if(matches.length>1){ printLine(matches.map(m=>m.type==='dir'?`<span class='dir'>${m.name}</span>`:`<span class='file'>${m.name}</span>`).join('  ')); }
      }
      return;
    }
    if(e.key==='Enter'){
    e.preventDefault();
    const raw = input.textContent.trim();
    input.removeAttribute('id');
    const caret = input.nextElementSibling;
    if(caret && caret.classList.contains('caret')) caret.remove();
    if(raw){ state.history.push(raw); state.histIdx = state.history.length; }
    handleShell(raw);
    }

  });

  function highlightSearch(q){
    const cont=document.getElementById('vi-content'); if(!cont) return;
    // remove old highlights
    cont.querySelectorAll('.hl').forEach(n=>{ const t=n.textContent; n.replaceWith(document.createTextNode(t)); });
    if(!q) return;
    const walk=(node)=>{
      if(node.nodeType===3){
        const idx=node.data.toLowerCase().indexOf(q.toLowerCase());
        if(idx>-1){ const span=document.createElement('span'); span.className='hl'; const before=node.splitText(idx); before.splitText(q.length); span.textContent=before.data; before.replaceWith(span); }
      } else if(node.nodeType===1){ Array.from(node.childNodes).forEach(walk); }
    };
    walk(cont);
  }
  function findNext(forward=true){
    const cont=document.getElementById('vi-content'); if(!cont||!state.vi.search) return;
    const matches=Array.from(cont.querySelectorAll('.hl'));
    if(!matches.length) return;
    state.vi._cursor = (state.vi._cursor ?? (forward? -1 : matches.length)) + (forward?1:-1);
    if(state.vi._cursor<0) state.vi._cursor=matches.length-1;
    if(state.vi._cursor>=matches.length) state.vi._cursor=0;
    const el=matches[state.vi._cursor]; el.scrollIntoView({block:'center'});
  }

  // Basic runtime tests to catch regex/behavior regressions
  function runTests(){
    const results = [];
    const pass = (name, ok, detail='')=> results.push({name, ok, detail});

    // 1) URL extraction
    pass('URL regex http', extractFirstUrl('see http://example.com/x')==='http://example.com/x');
    pass('URL regex https with )', extractFirstUrl('link (https://example.com/x)')==='https://example.com/x');

    // 2) whitespace split
    const parts = 'vi   Blog/hello-terminal.md'.trim().split(/\s+/);
    pass('split \\s+ works', parts.length===2 && parts[0]==='vi' && parts[1]==='Blog/hello-terminal.md');

    // 3) absolute URL open test
    pass('absolute URL detect', /^https?:\/\//i.test('HTTPS://EXAMPLE.com/abc'));

    // 4) cwd path cleanup
    const fake = ['/', {name:'Blog'},{name:''}];
    const old = state.cwd; state.cwd=[{name:'/'},{name:'Blog'}];
    pass('cwd render', getCwdPath()==='~/Blog');
    state.cwd = old;

    // 5) markdown renders heading + link
    const html = mdToHtml('# T\nSee [x](https://a.com)');
    pass('md heading', /<h1>/.test(html));
    pass('md link', /<a href="https:\/\/a\.com"/.test(html));

    // 6) binary checker
    pass('binary detect', isBinaryByExt('Resume.pdf') === true);

    // 7) focus checkers
    pass('isPrintableKey true', isPrintableKey({key:'a', ctrlKey:false, metaKey:false, altKey:false}) === true);
    pass('isPrintableKey false', isPrintableKey({key:'ArrowLeft', ctrlKey:false, metaKey:false, altKey:false}) === false);


    // Printing
    printLine('<strong>Running tests…</strong>');
    results.forEach((r,i)=> printLine(`${r.ok? '✅':'❌'} Test ${i+1}: ${r.name}${r.detail? ' — '+r.detail:''}`));
    const oks = results.filter(r=>r.ok).length;
    printLine(`<strong>${oks}/${results.length} passed</strong>`);

  }

  // boot
  function boot(){
    printLine(`Aadi Terminal Web Portfolio v0.2`);
    printLine(`Type 'help' to get started.`);
    const hash=decodeURIComponent(location.hash.slice(1));
    if(hash){ const parts=hash.split('/').filter(Boolean); const resolved=resolvePathTokensFrom([FS],parts); if(resolved.ok && resolved.stack.at(-1).type==='dir'){ state.cwd=resolved.stack; } }
    newInputLine();
  }
  boot();
  </script>
</body>
</html>
